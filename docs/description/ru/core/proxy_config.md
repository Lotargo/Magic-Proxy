# Руководство по конфигурации: `proxy_config.yaml`

## 1. Введение и философия

Файл `proxy_config.yaml` — это **единый пульт управления** всем поведением "Magic Proxy". Он позволяет вам, как администратору системы, проектировать сложные AI-архитектуры, управлять отказоустойчивостью и активировать продвинутые когнитивные функции, не изменяя ни строчки исходного кода.

**Ключевые принципы:**
*   **Декларативность**: Вы не программируете, а описываете желаемое состояние системы.
*   **Централизация**: Вся логика роутинга и определения моделей находится в этом одном файле, что упрощает управление и аудит.
*   **Явное лучше неявного**: Все настройки поведения задаются явно.

## 2. Основные концепции

Конфигурация строится на двух взаимосвязанных блоках: `model_list` и `router_settings`.

*   **`model_list` (Каталог профилей моделей)**: Это ваш полный и исчерпывающий каталог всех "строительных блоков" — профилей моделей. Каждый профиль описывает **одну конкретную конфигурацию** для вызова AI-модели.
*   **`router_settings` (Маршрутизация запросов)**: Этот блок определяет, какие модели доступны клиентам извне и как система должна реагировать на сбои. Он использует профили из `model_list` для построения **цепочек отказоустойчивости (fallback chains)**.

### 2.1. Шаг 1: Определение профиля модели в `model_list`

Каждый элемент в `model_list` — это **профиль**, описывающий, как вызвать одну конкретную модель.

```yaml
model_list:
  - model_name: "openai_main_gpt4"  # 1. Уникальное внутреннее имя профиля
    provider: "openai"              # 2. Идентификатор провайдера (адаптера)
    model_params:                   # 3. Параметры для вызова API
      model: "gpt-4-turbo"          #    - Имя модели у провайдера
      temperature: 0.7
      # ... другие параметры ...
```

**Структура профиля:**

*   `model_name` (**Обязательно**): Уникальное внутреннее имя этого профиля. На него вы будете ссылаться в `router_settings`.
*   `provider` (**Обязательно**): Строковый идентификатор, который сообщает шлюзу, какой внутренний "протокольный адаптер" из папки `providers/` использовать. Доступные значения: `google`, `openai`, `mistral`, `anthropic`, `deepseek`, `local`.
*   `model_params` (**Обязательно**): Словарь с параметрами для вызова модели.
    *   `model` (**Обязательно**): Реальное имя модели, как оно указано в документации провайдера (например, "gemini-1.5-flash-latest").
    *   `api_base` (Опционально): Позволяет переопределить стандартный URL OpenAI для использования openai-совместимых API от других провайдеров (Groq, Together AI, etc.).
    *   `temperature`, `top_p`, `max_tokens`: Стандартные параметры генерации. `null` означает "использовать значение по умолчанию от провайдера".

### 2.2. Шаг 2: Создание клиентского маршрута в `router_settings`

После того как вы определили один или несколько профилей, вы можете "опубликовать" их для клиентов через `router_settings`.

```yaml
router_settings:
  model_group_alias:
    "production-gpt4": # <-- 1. Псевдоним, который использует клиент
      # 2. Цепочка отказоустойчивости (fallback chain)
      - "openai_main_gpt4"
      - "azure_backup_gpt4"
```

**Как это работает:**
1.  **Псевдоним (`model_group_alias`)**: Ключ (`production-gpt4`) — это имя, которое ваше клиентское приложение должно указать в поле `model` своего API-запроса.
2.  **Цепочка приоритетов (`priority_chain`)**: Значение — это список из имен профилей (`model_name` из `model_list`), которые шлюз будет пытаться использовать по порядку.

Когда поступает запрос с `model: "production-gpt4"`, шлюз:
1.  Берет первый профиль из списка (`openai_main_gpt4`) и пытается выполнить запрос.
2.  Если попытка неудачна (API-провайдер недоступен или все ключи для него вышли из строя), шлюз автоматически берет второй профиль (`azure_backup_gpt4`) и повторяет попытку.
3.  Этот процесс продолжается до первого успешного выполнения или до конца списка.

## 3. Продвинутая конфигурация

### 3.1. Активация движка рассуждений (ReAct)

Вы можете "прокачать" любой профиль модели, активировав для него движок `react_driver`.

Для этого добавьте вложенный блок `agent_settings` в профиль модели:
```yaml
model_list:
  - model_name: "gemini-agent-profile"
    provider: "google"
    model_params:
      model: "gemini-1.5-flash-latest"
      agent_settings: # <-- Активируем ReAct
        reasoning_mode: "basic_react" # <-- Указываем когнитивный паттерн
```
*   `reasoning_mode`: Ключевой параметр. Указывает имя когнитивного паттерна, который будет использоваться для "обогащения" запроса. Имя должно соответствовать имени файла `*_react.py` в системной директории `react_patterns/`. Если блок `agent_settings` отсутствует, запрос обрабатывается как прямое проксирование.

### 3.2. Использование шаблонов (YAML Anchors)

Чтобы избежать дублирования, вы можете использовать YAML-якоря. Это особенно полезно для общих параметров, таких как `api_base`.

```yaml
definitions:
  # Шаблон с базовым URL для всех моделей Mistral
  mistral_common_params: &mistral_common_params
    api_base: https://api.mistral.ai/v1

model_list:
  - model_name: "mistral-small-profile"
    provider: "mistral"
    model_params:
      <<: *mistral_common_params # <-- Содержимое шаблона будет вставлено сюда
      model: "mistral-small-latest"
  - model_name: "mistral-large-profile"
    provider: "mistral"
    model_params:
      <<: *mistral_common_params # <-- И сюда тоже
      model: "mistral-large-latest"
```

## 4. Прочие системные настройки

Эти блоки управляют глобальным поведением шлюза.

*   `agent_settings`: Глобальные настройки для движка рассуждений.
    *   `mcp_server_url` (**Обязательно для ReAct**): URL-адрес запущенного сервера инструментов (`mcp_server.py`).
*   `streaming_settings`: Настройки потоковой передачи ответов.
    *   `typewriter_mode`: `"proxy"` (сервер имитирует эффект "пишущей машинки") или `"client"` (прозрачная пересылка "как есть").
*   `cache_settings`: Глобальное включение/выключение кэширования и правила кэширования.
*   `key_management_settings`: Настройки управления API-ключами.
    *   `enable_quarantine`: Включает механизм временной изоляции ключей, вернувших временные ошибки (rate limit и т.д.).
*   `provider_model_lists`: **(Только для UI)**. Этот блок не влияет на логику работы шлюза. Он предназначен исключительно для заполнения выпадающих списков в UI административной панели. Его необходимо обновлять вручную.