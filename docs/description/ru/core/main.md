# Техническая документация: `main.py` — Центральный оркестратор шлюза

## 1. Обзор

`main.py` — это **центральный исполнительный модуль (entrypoint)** и **оркестратор** для всего приложения "Magic Proxy". Он инициализирует, конфигурирует и запускает веб-приложение на базе FastAPI. Модуль выполняет роль "дирижера", связывая все независимые компоненты в единую, отказоустойчивую систему.

## 2. Архитектурная роль и решаемые проблемы

*   **Упорядоченная инициализация**: Гарантирует, что к моменту приема первого HTTP-запроса все зависимости (конфигурация, Redis, Kafka, менеджер ключей) и системы (логирование, трассировка) готовы к работе.
*   **Централизованная маршрутизация**: Предоставляет единый, OpenAI-совместимый API (`/v1/...`), который "прозрачно" перенаправляет запросы к наилучшему доступному AI-провайдеру на основе конфигурации.
*   **Обеспечение высокой доступности**: Абстрагирует от сбоев отдельных API-ключей или целых провайдеров, автоматически переключаясь на резервные варианты.
*   **Управляемость**: Предоставляет административный UI и API (`/admin/...`) для просмотра и изменения конфигурации и промптов "на лету" без перезапуска приложения.

## 3. Ключевые механизмы и логика работы

### 3.1. Управление жизненным циклом (`lifespan`)

Для управления ресурсами используется контекстный менеджер `lifespan` FastAPI. Это обеспечивает корректную и упорядоченную последовательность действий при старте и остановке приложения.

**При старте сервера:**
1.  Загружается конфигурация из `proxy_config.yaml`.
2.  Инициализируется система трассировки OpenTelemetry.
3.  Запускается `ApiKeyManager`, который загружает все ключи из `keys_pool/` и запускает фоновые задачи (например, возврат ключей из "карантина").
4.  Регистрируются все доступные провайдеры (адаптеры из `providers/`).
5.  Устанавливаются соединения с Redis и Kafka.
6.  Запускается фоновый воркер для обработки задач из Kafka (если включен `react_driver`).

**При остановке сервера:**
Все ресурсы (соединения с Kafka, Redis, фоновые задачи) корректно освобождаются.

### 3.2. Централизованная маршрутизация (`route_request`)

Это ядро "прозрачного" прокси. Все запросы к LLM (`/v1/chat/completions`, `/v1/embeddings` и др.) в конечном итоге обрабатываются этой функцией.

**Алгоритм работы:**
1.  Из тела запроса извлекается псевдоним модели (`model_alias`), например, `gpt-4-turbo`.
2.  В `proxy_config.yaml` находится соответствующая **цепочка приоритетов (priority_chain)** по этому псевдониму. Пример: `['openai_main_gpt4', 'azure_backup_gpt4']`.
3.  Если цепочка не найдена, возвращается ошибка 404.
4.  Система итеративно проходит по каждому имени профиля (`internal_model_name`) из цепочки.
5.  Для каждого профиля определяется его провайдер (например, "openai") и находится соответствующая функция-адаптер (например, `proxy_openai_compat_chat`).
6.  Управление передается механизму отказоустойчивости (`execute_request_with_key_rotation`), который пытается выполнить запрос с текущим провайдером.
7.  **При успехе**: результат немедленно возвращается клиенту.
8.  **При сбое**: логируется предупреждение, и цикл переходит к следующему провайдеру в цепочке.
9.  Если все провайдеры в цепочке оказались недоступны, возвращается ошибка 503 Service Unavailable.

### 3.3. Оркестрация отказоустойчивости (`execute_request_with_key_rotation`)

Эта функция инкапсулирует логику выполнения запроса к **одному** провайдеру, обеспечивая перебор всех доступных для него API-ключей.

**Алгоритм работы:**
1.  Определяется провайдер (например, "google") и запрашивается у `ApiKeyManager` количество доступных для него ключей, чтобы знать максимальное число попыток.
2.  Запускается цикл попыток:
    a. Запрашивается рабочий ключ у `ApiKeyManager`. Если свободных ключей нет, цикл прерывается.
    b. Вызывается функция-адаптер провайдера, передавая ей запрос, ключ и конфигурацию.
    c. **При успехе**: ключ возвращается в пул как рабочий, результат отдается `route_request`.
    d. **При ошибке `httpx.HTTPStatusError`**:
        *   **401 Unauthorized / "invalid api key"**: Ключ считается невалидным и **"сжигается"** (`retire_key`).
        *   **429 Too Many Requests / 5xx Server Error**: Ключ считается временно недоступным и отправляется в **"карантин"** на заданное время (`quarantine_key`).
        *   **400 Bad Request**: Ошибка в запросе пользователя; ключ не виноват и возвращается в пул, а ошибка пробрасывается клиенту.
    e. Переход к следующей попытке с новым ключом.
3.  Если все попытки исчерпаны, генерируется исключение `ProviderUnavailableError`, которое `route_request` использует как сигнал для переключения на следующего провайдера в цепочке.

## 4. API и UI для администрирования

Модуль предоставляет набор эндпоинтов в префиксе `/admin/` для управления приложением "на лету":

*   `GET, POST /admin/config`: Чтение и запись файла `proxy_config.yaml` с немедленной перезагрузкой конфигурации.
*   `GET, POST /admin/prompt_content`: Чтение и запись файлов системных промптов.
*   `GET /admin/react_patterns`: Получение списка доступных ReAct-паттернов.
*   `GET /admin/provider_models`: Получение списка моделей, указанных в конфигурации.
*   `POST /admin/restart`: Программный перезапуск сервера.

Кроме того, по корневому URL `/` раздается статический веб-интерфейс (`frontend/`), который предоставляет удобный UI для взаимодействия с этим API.

## 5. Зависимости и конфигурация

### 5.1. Ключевые зависимости

*   **Веб-сервер**: `fastapi`, `uvicorn`
*   **HTTP-клиент**: `httpx`
*   **Инфраструктура**: `redis` (для кэша и SSE), `aiokafka` (для ReAct)
*   **Конфигурация**: `pyyaml`
*   **Мониторинг**: `opentelemetry-*`

### 5.2. Внутренние модули

*   `key_manager`: Управление жизненным циклом API-ключей.
*   `providers`: Адаптеры для каждого AI-провайдера.
*   `react_driver`, `sse_driver`, `cache_manager`: Компоненты для продвинутых функций.
*   `utils`, `logging_config`, `tracing`: Вспомогательные утилиты.

### 5.3. Запуск

Для запуска сервера в режиме разработки используется `uvicorn`:
```bash
uvicorn main:app --host 0.0.0.0 --port 8001 --reload
```
(Примечание: для удобного запуска всех компонентов системы рекомендуется использовать `run.py`.)