# Техническая Документация: Модуль key_manager.py

## 1. Краткое Резюме

`key_manager.py` реализует класс `ApiKeyManager` — высокоуровневый, потокобезопасный и самовосстанавливающийся менеджер пулов API-ключей. Его задача — обеспечить максимальную надежность при взаимодействии с внешними API-провайдерами. Модуль инкапсулирует сложную логику управления жизненным циклом ключей: он автоматически классифицирует ошибки, изолирует временно сбоящие ключи в "карантин" и навсегда выводит из ротации скомпрометированные. Это обеспечивает грациозную деградацию и автономное восстановление системы.

## 2. Архитектурная Роль и Решаемая Проблема

При работе с платными внешними API в промышленных масштабах возникает ряд критических проблем:
*   **Временные сбои:** API-ключи часто имеют ограничения по частоте запросов (rate limits). Превышение лимита на одном ключе не должно парализовать всю систему.
*   **Перманентные сбои:** Ключи могут быть отозваны, их срок действия может истечь, или они могут быть невалидными. Система должна идентифицировать такие ключи и навсегда исключать их из ротации.
*   **Высокая конкурентность (Concurrency):** В асинхронной среде множество запросов могут пытаться использовать один пул ключей, что без синхронизации приводит к состоянию гонки.
*   **Операционная сложность:** Ручное управление десятками ключей, отслеживание их состояния и своевременное возвращение в строй требует значительных усилий.

`ApiKeyManager` решает эти проблемы, создавая абстракцию интеллектуального, отказоустойчивого "поставщика" ключей.

## 3. Ключевые Компоненты и Архитектурные Паттерны

### 3.1. Структура Данных и Конечный Автомат

В основе менеджера лежит словарь `_pools`, где для каждого провайдера хранится состояние его ключей. Каждый ключ может находиться в одном из трех состояний (пулов):
*   **available:** Список ключей, готовых к использованию. Работает по принципу FIFO (первый вошел — первый вышел).
*   **quarantined:** Словарь с ключами, временно изолированными из-за некритичной ошибки (например, rate limit). Хранит ключ, причину и время окончания карантина.
*   **retired:** Словарь с ключами, перманентно выведенными из эксплуатации из-за фатальной ошибки (невалидный токен).

Переход между состояниями управляется методами `quarantine_key` и `retire_key`.

### 3.2. Управление Жизненным Циклом Ключа

*   `get_key(provider)`: Атомарно извлекает первый доступный ключ из пула `available`.
*   `release_key(provider, key)`: Возвращает использованный ключ обратно в конец пула `available`.
*   `quarantine_key(provider, key, reason)`: Перемещает ключ из `available` в `quarantined` на заданное время (`QUARANTINE_DURATION_SECONDS`). Важно: эта логика активируется только если глобальный флаг `ENABLE_QUARANTINE` установлен в `True`. В противном случае ключ немедленно возвращается в `available` через `release_key`.
*   `retire_key(provider, key, reason)`: Перманентно перемещает ключ из любого состояния в `retired`, исключая его из дальнейшего использования.

### 3.3. Паттерн "Фоновый Воркер" (_check_quarantine)

Модуль запускает асинхронную фоновую задачу, которая периодически (каждые 10 секунд) проверяет пул `quarantined`. Если срок изоляции ключа истек, он автоматически возвращается в `available`. Это реализует паттерн самовосстановления (self-healing), снижая необходимость в ручном вмешательстве. Воркер запускается только при `ENABLE_QUARANTINE = True`.

### 3.4. Потокобезопасность (asyncio.Lock)

Все операции, изменяющие состояние пулов (`_pools`), защищены с помощью `asyncio.Lock`. Это гарантирует атомарность и предотвращает состояние гонки в высоконагруженной асинхронной среде FastAPI.

### 3.5. Загрузка и Конфигурация

*   **`load_all_keys()`**: При старте приложения метод сканирует директорию `keys_pool/` на предмет файлов `keys_pool{provider}.env`. Каждый файл содержит список API-ключей (по одному на строку).
*   **Централизованная Конфигурация**: Ключевые параметры вынесены в константы в начале файла:
    *   `ENABLE_QUARANTINE`: Глобальный переключатель, который полностью включает или отключает механизм карантина. Позволяет быстро изменить стратегию обработки ошибок без перезапуска.
    *   `QUARANTINE_DURATION_SECONDS`: Длительность изоляции ключа.
    *   `PERMANENT_KEY_ERROR_MESSAGES`, `REQUEST_CONTENT_ERROR_MESSAGES`: Наборы строковых маркеров, которые используются в `main.py` для принятия решения, какой метод менеджера вызвать (`quarantine_key`, `retire_key` или `release_key`).

## 4. Настройка и Конфигурация

Перед использованием `ApiKeyManager` необходимо правильно структурировать файлы с API-ключами.

### 4.1. Структура Файлов

1.  В корневой директории проекта создайте папку `keys_pool/`.
2.  Внутри `keys_pool/` создайте отдельные `.env` файлы для каждого провайдера. Название файла должно соответствовать формату `keys_pool_{provider_name}.env`.

**Важно:** Для всех сервисов Google (`google-embedding`, `google-stt`, `google-tts`) используется один и тот же файл, соответствующий основному провайдеру `google`.

**Пример структуры:**
```
.
├── keys_pool/
│   ├── keys_pool_google.env
│   └── keys_pool_openai.env
├── main.py
└── key_manager.py
```

### 4.2. Содержимое Файлов

Каждый файл должен содержать список API-ключей, по одному ключу на строку. Пустые строки и пробелы по краям игнорируются.

**Пример `keys_pool_openai.env`:**
```
sk-proj-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
sk-proj-yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
sk-proj-zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz
```

## 5. Пример Интеграции и Использования (Workflow)

`ApiKeyManager` раскрывает свою полную мощь при интеграции в логику обработки запросов, например, в модуле `main.py`. Ниже представлен упрощенный, но репрезентативный пример функции, которая надежно выполняет вызов к внешнему API, используя менеджер.

### 5.1. Пример Кода
```python
# Этот код является упрощенным примером того, как может выглядеть
# функция-оркестратор, использующая ApiKeyManager.
import httpx
from fastapi import Request

async def safely_call_provider(request: Request, provider: str, payload: dict):
    """
    Надежно выполняет API-запрос, используя ApiKeyManager для ротации,
    карантина и изъятия ключей.
    """
    key_manager = request.app.state.key_manager
    # Определяем максимальное количество попыток на основе доступных ключей
    status = await key_manager.get_full_status()
    max_attempts = status.get(provider, {}).get('available', 0) + 1

    last_exception = None

    for attempt in range(max_attempts):
        # 1. Запрашиваем ключ из пула
        api_key = await key_manager.get_key(provider)
        if not api_key:
            last_exception = Exception(f"Все ключи для '{provider}' исчерпаны.")
            break # Прерываем цикл, если ключи кончились

        try:
            # 2. Выполняем вызов внешнего API
            async with httpx.AsyncClient() as client:
                response = await client.post("https://api.provider.com/v1/...", json=payload, headers={"Authorization": f"Bearer {api_key}"})
                response.raise_for_status() # Вызовет исключение для кодов 4xx/5xx

            # 3. При УСПЕХЕ - возвращаем ключ и результат
            await key_manager.release_key(provider, api_key)
            return response.json()

        except httpx.HTTPStatusError as e:
            last_exception = e
            error_message = str(e).lower() # Анализируем текст ошибки

            # 4. При ОШИБКЕ - классифицируем ее и реагируем
            if any(msg in error_message for msg in PERMANENT_KEY_ERROR_MESSAGES):
                # Фатальная ошибка ключа -> "сжигаем" его
                await key_manager.retire_key(provider, api_key, f"HTTP {e.response.status_code}")
            elif e.response.status_code in [429, 500, 502, 503]:
                # Временная ошибка сервера/лимитов -> в карантин
                await key_manager.quarantine_key(provider, api_key, f"HTTP {e.response.status_code}")
            else:
                # Другая ошибка (например, 400 Bad Request из-за неверного промпта)
                # -> просто возвращаем ключ, так как он не виноват
                await key_manager.release_key(provider, api_key)
                raise e # Пробрасываем ошибку дальше, т.к. она связана с запросом

            # ... и переходим к следующей попытке с новым ключом

        except Exception as e:
            # Непредвиденная ошибка (например, разрыв соединения)
            last_exception = e
            await key_manager.release_key(provider, api_key) # На всякий случай возвращаем ключ
            continue

    # Если все попытки провалились
    raise Exception(f"Не удалось выполнить запрос к '{provider}' после {max_attempts} попыток. Последняя ошибка: {last_exception}")
```

### 5.2. Разбор Примера

*   **Запрос Ключа:** Цикл начинается с запроса ключа через `await key_manager.get_key(provider)`. Это атомарная, потокобезопасная операция.
*   **Вызов API:** Ключ используется в `try...except` блоке. Это критически важно, так как позволяет перехватывать и анализировать ошибки.
*   **Обработка Успеха:** При успешном выполнении запроса (код 2xx), ключ обязательно возвращается в пул через `await key_manager.release_key(...)`, чтобы другие запросы могли его использовать.
*   **Обработка Ошибок (ключевая логика):**
    *   Если API возвращает ошибку, которая явно указывает на проблему с ключом (невалидный, истек срок действия), вызывается `retire_key`. Ключ навсегда выводится из ротации.
    *   Если ошибка временная (rate limit, сервер недоступен), вызывается `quarantine_key`. Ключ временно изолируется и будет автоматически возвращен в пул фоновым воркером.
    *   Если ошибка связана с содержимым запроса (400 Bad Request), ключ не виноват. Он просто возвращается в пул через `release_key`, а исключение пробрасывается выше, чтобы клиент получил сообщение об ошибке.
*   **Цикл Повторных Попыток:** Вся эта логика обернута в цикл. Если один ключ выходит из строя (помещается в карантин или сжигается), цикл просто переходит к следующей итерации и запрашивает у менеджера следующий доступный ключ, обеспечивая бесшовный фолбэк.

## 6. Архитектурная Ценность и Бизнес-Эффект

`ApiKeyManager` — это критически важный компонент инфраструктуры надежности.
*   **Повышение Доступности (High Availability):** Путем автоматической ротации и изоляции сбойных ключей система продолжает обслуживать запросы, даже если часть ее ресурсов недоступна.
*   **Снижение Операционных Затрат:** Автоматизация процессов карантина и "сжигания" ключей минимизирует время, которое инженеры тратят на ручную диагностику.
*   **Оптимизация Расходов:** Предотвращение повторных запросов с заведомо неработоспособных ключей экономит вычислительные ресурсы и деньги.
*   **Наблюдаемость:** Метод `get_full_status` предоставляет необходимую телеметрию для систем мониторинга, позволяя отслеживать "здоровье" пула ключей в реальном времени.

В итоге, `ApiKeyManager` превращает хаотичный набор статических API-ключей в динамичный, адаптивный и отказоустойчивый ресурс, что является обязательным требованием для построения масштабируемых облачных приложений.