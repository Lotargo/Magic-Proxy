# Техническая Документация: Frontend-логика (ui.js)

## 1. Краткое Резюме
`ui.js` — это основной JavaScript-модуль, который "оживляет" всю UI Песочницу. Он управляет состоянием приложения, обрабатывает взаимодействие с пользователем, общается с бэкенд-API и динамически обновляет DOM для отображения данных. Модуль построен вокруг асинхронной модели с четким разделением на инициализацию, обработку событий и рендеринг компонентов.

## 2. Архитектура и Управление Состоянием

### 2.1. Глобальное Состояние (Global State)
В верхней части файла определен ряд глобальных переменных, которые служат in-memory кэшем и источником правды для всего приложения.
*   `ALL_MODELS_DATA`, `ALL_PROMPTS`, `ALL_MANIFESTS`, `ALL_PATTERNS`: Эти массивы заполняются один раз при загрузке страницы. Все последующие операции (отрисовка списков, запуск сессий) используют эти закэшированные данные, что минимизирует количество запросов к API и ускоряет работу интерфейса.
*   `originalConfigContent`, `originalPromptContent`, `originalManifestContent`: Эти переменные хранят "эталонное" состояние конфигурационных файлов на момент их загрузки. Они используются для сравнения (diff), чтобы определить, были ли внесены изменения.

### 2.2. Модуль `api.js` (Абстракция API)
Весь код, отвечающий за HTTP-запросы (`fetch`), вынесен в отдельный модуль `api.js` (не показан). `ui.js` никогда не работает с `fetch` напрямую, а вызывает высокоуровневые функции, такие как `api.fetchRunnableModels()` или `api.saveConfig()`. Это классический паттерн "Слой Доступа к Данным" (Data Access Layer), который делает основной код чище и упрощает его тестирование.

## 3. Жизненный Цикл Приложения

*   **`DOMContentLoaded` (Точка входа):**
    *   Скрипт начинает работу после полной загрузки HTML.
    *   Первым делом вызывается `loadAllInitialData()`.
*   **`loadAllInitialData()` (Инициализация состояния):**
    *   Эта асинхронная функция одновременно (через `Promise.all`) запрашивает у бэкенда все необходимые для работы данные: список моделей, промптов, манифестов и ReAct-паттернов.
    *   После получения данные записываются в глобальные переменные.
*   **Инициализация Вкладок (`init*`):**
    *   После загрузки данных последовательно вызываются функции `initPromptsTab()`, `initAdminPanel()` и `initPlayground()`. Каждая из этих функций отвечает за рендеринг начального состояния и навешивание обработчиков событий для своей вкладки.

## 4. Ключевые Логические Блоки

### 4.1. Логика "Playground" (`initPlayground`, `handleSessionRequest`)
*   **Рендеринг:** `renderModelCheckboxes()` и `renderPlaygroundReactOverrides()` динамически создают HTML для списков моделей и настроек ReAct на основе данных из `ALL_MODELS_DATA`, `ALL_PROMPTS` и `ALL_MANIFESTS`.
*   **Запуск Сессии (`handleSessionRequest`):**
    *   Собирает все данные с UI: текст запроса, ID выбранных моделей, настройки безопасности и "переопределения" ReAct-промптов.
    *   **Различает агентов и простые чаты:** Проверяет флаг `modelData.is_agent`.
        *   Если `true`, формирует сложный `payload` для эндпоинта `/v1/react/sessions` и вызывает `api.runAgent()`.
        *   Если `false`, формирует простой `payload` для `/v1/chat/completions` и вызывает `api.runSimpleChat()`.
    *   Для каждой запущенной модели создает отдельную колонку в UI (`createAgentColumn`).
    *   Передает "тело" потокового ответа (`response.body`) в специализированные функции-парсеры (`processReActStream` или `processOpenAIStream`).

### 4.2. Обработка Потоков (`processReActStream`, `processOpenAIStream`)
Эти асинхронные функции — "сердце" интерактивности.
*   **`processOpenAIStream`:** Относительно простой парсер. Он читает SSE-поток, извлекает `content` из JSON-частей и постепенно накапливает его, обновляя UI. В конце он рендерит полный ответ как Markdown.
*   **`processReActStream`:** Значительно более сложный. Это конечный автомат (state machine), который парсит структурированные события от `sse_driver`.
    *   Он отслеживает текущее состояние (идет ли "мысль", "действие" или "финальный ответ").
    *   Динамически создает и обновляет `details` (`<summary>`) элементы для каждого шага мышления.
    *   Реагирует на разные `event_type` (`AgentThoughtStream`, `AgentToolCallStart`, `FinalAnswerStreamEnd` и т.д.), чтобы правильно рендерить разные части UI.
    *   Имеет встроенный таймаут: если от потока долго не поступает данных, он принудительно завершает обработку, чтобы избежать "зависшего" UI.

### 4.3. Логика Админ-Панели (`initAdminPanel`, `handleSaveConfig`)
*   **Структурированное Редактирование:** `model_list` не редактируется как "сырой" YAML. Функция `renderModelListEditor` парсит этот массив и создает интерактивную таблицу, где каждое поле — это отдельный `input` или `select`. Это защищает пользователя от синтаксических ошибок в YAML.
*   **"Живой" Diff:** При любом изменении в редакторах (как в таблице, так и в текстовых полях) вызывается `renderDiff`. Эта функция:
    *   Собирает текущее состояние UI в новый объект JavaScript (`getCurrentConfigAsObject`).
    *   Конвертирует его в строку YAML.
    *   Сравнивает с `originalConfigContent`.
    *   Использует библиотеку `Diff2HtmlUI` для рендеринга наглядного side-by-side сравнения.
*   **Сохранение и Перезапуск:** `handleSaveConfig` отправляет полное новое содержимое `proxy_config.yaml` на бэкенд. Параметр `restartAfterSave` управляет тем, какой именно эндпоинт будет вызван (`/admin/config` или `/admin/restart`).

### 4.4. Логика Редактора Промптов (`initPromptsTab`)
Работает по схожему с админ-панелью принципу: загружает контент файла, хранит его в `original*Content`, а при изменении в `textarea` рендерит `diff` и активирует кнопку сохранения.